---
title: 'Attrition Package'
date: 'This version: December 2021'
output: 
  html_document: 
    pandoc_args: ["--lua-filter=color-text.lua"]
    toc: true
    toc_float: true
    number_sections: true
    theme: united
  pdf_document: 
    pandoc_args: ["--lua-filter=color-text.lua"]
    keep_tex: true
header-includes:
  - \preauthor{\centering\large}
  - \predate{\centering\normalsize}
  - \pretitle{\centering\Large\textbf}
  - \usepackage{setspace}\onehalfspacing
  - \usepackage{xcolor}
  - \usepackage[shortlabels]{enumitem}
  - \usepackage{pgf,tikz, mathabx}
  - \usetikzlibrary{positioning}
editor_options:
  chunk_output_type: console
---
<style>

table, td, th {
  border: none;
  padding-left: 1em;
  padding-right: 1em;
  margin-left: auto;
  margin-right: auto;
  margin-top: 1em;
  margin-bottom: 1em;
}

</style>

```{cat, engine.opts = list(file = "color-text.lua")}
Span = function(span)
  color = span.attributes['color']
  -- if no color attribute, return unchange
  if color == nil then return span end
  
  -- tranform to <span style="color: red;"></span>
  if FORMAT:match 'html' then
    -- remove color attributes
    span.attributes['color'] = nil
    -- use style attribute instead
    span.attributes['style'] = 'color: ' .. color .. ';'
    -- return full span element
    return span
  elseif FORMAT:match 'latex' then
    -- remove color attributes
    span.attributes['color'] = nil
    -- encapsulate in latex code
    table.insert(
      span.content, 1,
      pandoc.RawInline('latex', '\\textcolor{'..color..'}{')
    )
    table.insert(
      span.content,
      pandoc.RawInline('latex', '}')
    )
    -- returns only span content
    return span.content
  else
    -- for other format return unchanged
    return span
  end
end
```

<!-- # Packages: -->

```{r,echo=FALSE,eval=TRUE,message=FALSE,warning=FALSE}
rm(list=ls())
library("dplyr")
library("ggplot2")
library(Hmisc)
library(gridExtra)
library(grid)
library("stargazer")
library("hrbrthemes")
#hrbrthemes::import_roboto_condensed()
library("quanteda")
library("readtext")
library("tidyverse")
library("knitr")
library("papeR")
library(tidyr)
library(kableExtra)
library(ggpubr)
library("printr")
library("tab")
#library("lfe")
library(sjPlot)
library(clusterSEs)
library(viridis)
library(BBmisc)
library(miceadds)
library(estimatr)
library(foreign)
library(randomizr)
library(doParallel)
library(sandwich)
library("table1")
library(matrixStats)
```


```{r,echo=FALSE,eval=TRUE,message=FALSE,warning=FALSE}
# ----------------------------------------------------------------------
# Function 1: skip_to_attrite()
# ----------------------------------------------------------------------

#This function takes a matrix of 0,1s in which 1 indicates missingness (NA) per respondent per question and removes `skippers`. Skippers are individuals who have a 0s in their row followed by 1s.

skip_to_attrite<-function(arg){
    n_col = length(arg)
    for (j in 1:n_col)
       {
      if (prod(arg[j:n_col])==1)
        {
          arg[j] = 1
        } 
      else 
        {
          arg[j] = 0
         }
    }
    return(arg)
}
# ----------------------------------------------------------------------
# Function 2: attrition()
# ----------------------------------------------------------------------

#Function to transform dataframe into an attrition dataframe. The attrition dataframe indicates, per variable, how many respondents attrited [note that this dataframe does not include `skippers`, i.e. respondents who skipped questions]. The dataframe also includes a variable that is the proportion of total N attrited, calculated as number of attrited respondents / number of respondents entering into the question.

#only works if you know the order of survey questions. 

attrition <- function(data)
  {
  #required packages
  require(ggplot2)
  require(viridis)
  require(Hmisc)
  require(dplyr)
  
  #make sure arguments are correct
  if(is.null(data))
  stop("Data is null, please supply value")
  
  if(class(data)!="data.frame")
  stop("Data must be data.frame")
  
  #for each missing value in the dataframe `dataset` give value 1, otherwise give 0.
  data <- apply(data,2,function(x) {ifelse(is.na(x),1,0)})

  #change `skippers` into 0 (we are only interested in respondents that attrited).
 
  data<-apply(data,1,skip_to_attrite)
  data<-t(data) #transpose data

  data2<-data.frame(data)

  #transform into a long dataframe, such that the variable `attrited` is the number of missing observations per variable.
 data <- data.frame(colSums(data2))
 colnames(data) <- "attrited"
 
 #transform `attrited` to measure how many respondents attrited during each question, rather than how many missing values are in each question.
 attrite_2<-data$attrited
 num_dropped <- data[-1,] - data[-nrow(data),]
 data$attrited<- c(data[1,], num_dropped)
 data$attrite_2<-attrite_2
 
  #add variable `proportion` = number of attrited respondents / number of respondents entering into the question
 data$n_prev <- nrow(data2) - as.numeric(data$attrite_2)
 data$n_prev <- Lag(data$n_prev, +1)
 data$n_prev[1] <- nrow(data2)
 data$proportion <-    round(data$attrited/data$n_prev,2)
 data$n_prev <- NULL
 data$attrite_2 <- NULL
 
 #proportion of attrited / starting N
 #data$proportion2 <- round(data$attrited/nrow(data2),2)
 
 #add variable `questions` = the name of each variable in the original dataframe.
 data$questions <- rownames(data)
 rownames(data) <- c()
 
  #return dataframe
  return(data)
}

#attrition_dataset<-attrition(data = df)

# ----------------------------------------------------------------------
# Function 3: plot_attrition()
# ----------------------------------------------------------------------

#Function that allows you to plot attrition in survey data.

#`data` must be data.frame. Note that this function works only if the order of variables = order of questions in the survey.

#`freq` is a logical argument that notes the Y axis of the attrition plot. Default is freq=TRUE, which is the frequency of attrited respondents. When freq=FALSE Y axis is the proportion of total N attrited, calculated as number of attrited respondents / number of respondents entering into the question.

#`treatment` is a character of name(s) of question(s) in which treatments were administered. Marked in the plot with a red vertical line.

#`pre_treatment` is a character of name(s) of pre-treatment question(s). Marked in the plot with a green vertical line.

#`DV` is a character of name(s) of outcome question(s). Marked in the plot with a blue vertical line.

#`other_group_var` is a character of name(s) of question(s), corresponds to `other_group` category, specified by users. Marked in the plot with a purple vertical line. Note that both `other_group` and `other_group_var` must be specified to use one of the functions.

#`other_group` is a character of the name of the group of variables specified in `other_group_var`. Note that both `other_group` and `other_group_var` must be specified to use one of the functions.

plot_attrition <- function(data
                           ,freq = TRUE
                           ,treatment = NULL
                           ,pre_treatment = NULL
                           ,DV = NULL
                           ,other_group = NULL
                           ,other_group_var = NULL
                           ,title = NULL)
  { 
  #required packages
  require(ggplot2)
  require(viridis)
  require(Hmisc)
  require(dplyr)

  #make sure arguments are correctly specified
  if(is.null(data))
  stop("Data is null, please supply value")
  
  if(class(data)!="data.frame")
  stop("Data must be data.frame")
  
  if(class(freq)!="logical")
  stop("Freq must be logical. Default is freq=TRUE.")
  
  if(!is.null(treatment) & class(treatment)!="character")
  stop("Treatment must be character")
  
  if(!is.null(pre_treatment) & class(pre_treatment)!="character")
  stop("Pre_treatment must be character")
  
  if(!is.null(DV) & class(DV)!="character")
  stop("DV must be character")
  
  if(!is.null(other_group) & class(other_group)!="character")
  stop("Other_group must be character")
  
  if(!is.null(other_group_var) & class(other_group_var)!="character")
  stop("Other_group_var must be character")
  
  #both other_group_var and group_var must be specified to use either:
  if(!is.null(other_group_var) & is.null(other_group))
  stop("Specify name of other_group")
  
  if(is.null(other_group_var) & !is.null(other_group))
  stop("Specify other_group_var")

 
 #Begin by creating an attrition dataframe
 #for each missing value in the dataframe `dataset` give value 1, otherwise give 0.
  data <- apply(data,2,function(x) {ifelse(is.na(x),1,0)})

  #change `skippers` into 0 (we are only interested in respondents that attrited).
 
  data<-apply(data,1,skip_to_attrite)
  data<-t(data) #transpose data

  data2<-data.frame(data)
  
  #transform into a long dataframe, such that the variable `attrited` is the number of missing observations per variable.
 data <- data.frame(colSums(data2))
 colnames(data) <- "attrited"
 
 #transform `attrited` to measure how many respondents attrited during each question, rather than how many missing values are in each question.
 attrite_2<-data$attrited
 num_dropped <- data[-1,] - data[-nrow(data),]
 data$attrited<- c(data[1,], num_dropped)
 data$attrite_2<-attrite_2
 
  #add variable `proportion` = number of attrited respondents / number of respondents entering into the question
 data$n_prev <- nrow(data2) - as.numeric(data$attrite_2)
 data$n_prev <- Lag(data$n_prev, +1)
 data$n_prev[1] <- nrow(data2)
 data$proportion <-   round(data$attrited/data$n_prev,2)
 data$n_prev <- NULL
 data$attrite_2 <- NULL
 
 #add variable `questions` = the name of each variable in the original dataframe.
 data$questions <- rownames(data)
 rownames(data) <- c()
 data$questions <- factor(data$questions, levels=data$questions)

  #Next, plot attrition
  #set colors for plots
   tmp_colors<-viridis(n=2,alpha=0.6,begin=0.25,end=1,direction=1,option="D")
   
  #create figure for if treatment is not NULL and freq = TRUE
    p <- data %>%
    ggplot(aes(questions,{if(freq==FALSE){proportion}else{attrited}})) + 
      #add if statement based on freq
          
      geom_histogram(color="#e9ecef", alpha=0.6, stat = 'identity') +
      scale_fill_manual(values=tmp_colors) 
    
     #vlines
      
      #add vline for other_group, only if it isn't null
    if(!is.null(other_group)) {
      p <- p + geom_vline(data= data.frame(type=other_group, 
                                col=other_group, other_group_var = other_group_var),
                                aes(colour=col, xintercept = match(other_group_var,data$questions)), #other_group_var), 
                                size = 0.7, show.legend = TRUE)} 
      #add vline for treatment, only if it isn't null   
    if(!is.null(treatment)){
      p <- p + geom_vline(data= data.frame(type="Treatment", 
                                col="Treatment", treatment = treatment),
                                aes(colour=col, xintercept = treatment), 
                                size = 0.7, show.legend = TRUE)}
      #add vline for pre_treatment, only if it isn't null   
    if(!is.null(pre_treatment)){
      p <- p + geom_vline(data= data.frame(type="Pre-Treatment", 
                                col="Pre-Treatment", pre_treatment = pre_treatment),
                                aes(colour=col, xintercept = pre_treatment), 
                                size = 0.7, show.legend = TRUE)}
      #add vline for DV, only if it isn't null   
    if(!is.null(DV)){
      p <- p + geom_vline(data= data.frame(type="Outcome", 
                                col="Outcome", DV = DV),
                                aes(colour=col, xintercept = DV), 
                                size = 0.7, show.legend = TRUE)} 
    
    #delete gray background  
    
    p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                          panel.background = element_blank(),
          axis.text.x = element_text(angle = 90, hjust = 1, size = 8))   
      
     #add legend details manually  
    p<- p + scale_colour_manual(name="Legend"
                      ,breaks = c("Treatment","Pre-Treatment","Outcome",other_group)
                      ,labels = c("Treatment","Pre-Treatment","Outcome",other_group)
                      ,values = c("firebrick","goldenrod3","royalblue3","seagreen")
                     ) +
      
        
    labs(x = "Survey Questions") + #titles
    labs(y = {if(freq==FALSE){"Proportion of respondents attrited"}
      else{"Respondents attrited"}}) #add if statement based on freq==FALSE
    
    if(freq == FALSE){print(p+ylim(0,1))}else{print(p)} #define limits of Y axis if freq==FALSE
    
}


#If question is factor, define value of `factor` you are interested in. For example, `female`. 

balance <- function(data, treatment, 
                    question,
                    factor = FALSE,
                    factor_name = NULL)
  { 

  #make sure arguments are correctly specified
  if(is.null(data))
  stop("Data is null, please supply value")
  
  if(class(data)!="data.frame")
  stop("Data must be data.frame")
  
  if(is.null(treatment))
  stop("Treatment is null, please supply value")
  
  if(class(treatment)!="character")
  stop("Treatment must be a character")

  if(is.null(question))
  stop("Question is null, please supply value")
  
  if(class(question)!="character")
  stop("Question must be a character")
  
  if(class(factor)!="logical")
  stop("Factor must be logical. Default is factor=FALSE")
  
  if((factor=FALSE) & !is.null(factor_name))
  stop("Factor must be TRUE if factor_name is defined")
  
  if(!is.null(factor_name) & class(factor_name)!="character")
  stop("Factor must be character")
  
  #subset datasets based on treatment and control arms
  
 data <- rename(data, question1 = question, 
                treatment1 = treatment)
  
  treat_data<-data[ which(data$treatment1=='treatment'), ]
  control_data<- data[ which(data$treatment1=='control'), ]

  if(is.null(factor_name)){
    test <- t.test(treat_data$question1, control_data$question1) #if question is not a factor, run t.test
  }else{
   
  
    #define factor treatment and control
    factor_treat<- treat_data[ which(treat_data$question1==factor_name), ]
    factor_control<- control_data[ which(control_data$question1==factor_name), ]
    
    #define not_factor treatment and control
    not_factor_treat<- treat_data[ which(treat_data$question1 != factor_name), ]
    not_factor_control<- control_data[ which(control_data$question1 != factor_name), ]
    
    #run two sample proportion test
   test <- prop.test(c(nrow(factor_treat), nrow(factor_control)),  
              c(nrow(factor_treat)+nrow(not_factor_treat), 
                nrow(factor_control)+nrow(not_factor_control)))
  }
  
print(test)
}

```


# Introduction

Attrition, the loss of study units from a sample, can pose a threat to inference. There are several studies, and accompanying R packages, that provide ex-post solutions to missingness such as double-sampling or extreme bounds. However, using the `Attrition` package, you can identify attrition after piloting and prevent it from occurring at the design stage.

# Usage

* Visualizing survey attrition across treatment condition and over-time.
* Utilizing and comparing balace tests at percise moments in the survey.
* Incorporating estimation and visualization of Manski bounds for studies suffering from broblematic attrition.

# Assumptions
* Data must be *ordered by survey questions*, i.e. if respondents answered Q1 before Q2, the variable Q1 must appear before Q2 in the dataframe.
* Skippers, i.e. respondents who skipped questions, are not reported as attrited.
* For balance tests, treatment and control conditions must be defined. 

# Arguments

*`plot_attrition()` function:*

* `data` - must be data.frame where variables are ordered by survey questions.
* `freq` - logical argument that notes the Y axis of the attrition plot. Default is freq=TRUE, which is the frequency of attrited respondents. When freq=FALSE Y axis is the proportion of total N attrited, calculated as number of attrited respondents / number of respondents entering into the question.
* `treatment` - character of name(s) of question(s) in which treatments were administered. Marked in the plot with a red vertical line.
* `pre_treatment` - character of name(s) of pre-treatment question(s). Marked in the plot with a green vertical line.
* `DV` - character of name(s) of outcome question(s). Marked in the plot with a blue vertical line.
* `other_group_var` - character of name(s) of question(s), corresponds to `other_group` category, specified by users. Marked in the plot with a purple vertical line. Note that both `other_group` and `other_group_var` must be specified to use one of the functions.
* `other_group` - character of the name of the group of variables specified in `other_group_var`. Note that both `other_group` and `other_group_var` must be specified to use one of the functions.


*`balance()` function:*

* `data` - must be data.frame.
* `treatment` - character that corresponds to the name of the treatment variable. Note that values of said variable must be specified as `treatment` and `control`.
* `question` - character that corresponds to the name of the point in survey (question), for which balance test is required.
* `factor` - Logical argument that specifies whether `question` is a factor. Default is factor = FALSE (i.e. question is a numeric or integer).
* `factor_name` - character that corresponds to specific factor (i.e. female), if question is a factor (i.e. sex). 


# Example

Let's begin demonstrating the uses of `Attrition`, with a working example. 

```{r call-data, echo=FALSE, eval=TRUE, message=FALSE,warning=FALSE}
#Load data
test_data<-read.csv("test_data.csv") 
test_data$X<-NULL #remove running numbers

```

After loading the test data (from Lo, Renshon, and Bassan-Nygate 2021, study 5B) and ensuring that variables are ordered by survey questions, we may want to transform our dataframe to an attrition dataframe, using the function `attrition`.

## Attrition dataframe
```{r attrition dataframe A, echo=TRUE, eval=TRUE, message=FALSE,warning=FALSE}
attrition_data <- attrition(test_data)
```

This function creates a frame that indicates, per variable, how many respondents attrited, as well as the proportion of total N attrited which is calculated as *number of attrited respondents / number of respondents entering into the question*.

Using base `R` we can explore how many people attrited overall, and what proportion of the general population this is.

```{r arrtition dataframe B, echo=TRUE, eval=TRUE, message=FALSE,warning=FALSE}
sum(attrition_data$attrited) #How many respondents attrited overall?
sum(attrition_data$attrited)/nrow(test_data) #What proportion of the overall sample is this? (0.21)
```

Next, we can look at specific variables, and learn whether respondents attrited. Let's choose the variable `cards_a` to demonstrate. Using base `R` we can extract the number of attrited respondents, as well as the proportion of total N attrited, for this question.

```{r arrtition dataframe C, echo=TRUE, eval=TRUE, message=FALSE,warning=FALSE}
attrition_data[attrition_data$questions == 'cards_a', 'attrited']
attrition_data[attrition_data$questions == 'cards_a', 'proportion']
```

We learn that at the question `cards_a` 37 respondents attrited from the survey. This is equivalent to 6% of the number of respondents who entered the survey at this question.

## Plot attrition

We may want to visualize attrition across the survey, to look at all the survey questions at once. The function `plot_attrition` allows us to plot attrition across survey questions, indicating pre-treatment, treatment, mediators, and outcome questions with different color vertical lines. To do so, use the original `test_data` dataframe, and *not* the `attrition_data`. 


```{r plot_attrition A, echo=TRUE, eval=TRUE, message=FALSE,warning=FALSE}

plot_attrition(data = test_data
               ,treatment = c("treat1", "treat2", "treat3")
              ,pre_treatment = c("consent", "age", "sex", "education", "state", "income", "part_id", "race", "religion", "attrition_1", "attrition_2", "cards_a", "pa", "pb_1", "pb_2", "pb_3", "pc", "cards_b", "p2a", "p2b_1", "p2b_2", "p2b_3", "p2c")
               ,DV = c("cards1", "cards2",  "cards3")
               ,other_group = "Mediators"
               ,other_group_var = c("Happy_1_1", "Happy_1_2", "Happy_1_3",
                                    "Happy_2_1", "Happy_2_2", "Happy_2_3",
                                    "Happy_3_1", "Happy_3_2", "Happy_3_3")
               ,freq = TRUE
               )  

```

We can also specify `freq = FALSE` so that Y axis will indicate the proportion of total N attrited.

```{r plot_attrition B, echo=TRUE, eval=TRUE, message=FALSE,warning=FALSE}

plot_attrition(data = test_data
               ,treatment = c("treat1", "treat2", "treat3")
              ,pre_treatment = c("consent", "age", "sex", "education", "state", "income", "part_id", "race", "religion", "attrition_1", "attrition_2", "cards_a", "pa", "pb_1", "pb_2", "pb_3", "pc", "cards_b", "p2a", "p2b_1", "p2b_2", "p2b_3", "p2c")
               ,DV = c("cards1", "cards2",  "cards3")
               ,other_group = "Mediators"
               ,other_group_var = c("Happy_1_1", "Happy_1_2", "Happy_1_3",
                                    "Happy_2_1", "Happy_2_2", "Happy_2_3",
                                    "Happy_3_1", "Happy_3_2", "Happy_3_3")
               ,freq = FALSE
               )  

```

## Balance tests

Once we have identified the specific survey points where attrition takes place, we want to conduct balance tests at these specific points to ensure balance across treatment and control, and learn if (and when) balance became an issue. We can do this using the function `balance`. 

Using the visualization, we've identified that attrition happens at two main points in time during the survey: at the pre-treatment question `cards_a`, and at the post-treatment question `Happy_3_1`. We demonstrate the use of the function `balance()` with both of these questions.

Note that you must define `treatment` and `control` arms under the `treatment` variables. 

```{r balance, echo=TRUE, eval=TRUE, message=FALSE,warning=FALSE}

balance(data = test_data, 
        treatment = "treat1", 
        question = "cards_a")

```

We can also use the function `balance()` when the `question` is a factor, but we must specify which factor we are interested in. For example, let's say we want to test whether at the question `sex` in the survey missingness created observable differences across treatment and control groups. Sex is a factor variable with two factors: female and male. We can look at whether the proportion of female still remains similar across groups. To do so, we must determine that `factor = TRUE` and specify the `factor_name` (in this case, female).

```{r balance 2, echo=TRUE, eval=TRUE, message=FALSE,warning=FALSE}

balance(data = test_data, 
        treatment = "treat1", 
        question = "sex",
        factor = TRUE,
        factor_name = "female")

```

When the question of interest is a numeric the relevant balance test is a t-test, and when the question of interest is a factor, the relevant balance test would be 2-sample proportion test. 

Note that so far we've looked at pre-treatment attrition. However, pre-treatment attrition doesnt pose a threat to internal validity since non-attriters can still be randomly assigned to arms and probabilistic equivalence can be achieved. Let's examine balance when post-treatment attrition occured by examining the variable `Happy_3_1`. This variable is a numberic, so there is no need to specify `factor` and `factor_name`.

```{r balance 3, echo=TRUE, eval=TRUE, message=FALSE,warning=FALSE}

balance(data = test_data, 
        treatment = "treat1", 
        question = "Happy_3_1")

```

