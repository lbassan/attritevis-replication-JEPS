---
title: 'Attrition'
date: 'This version: September 2021'
output: 
  html_document: 
    pandoc_args: ["--lua-filter=color-text.lua"]
    toc: true
    toc_float: true
    number_sections: true
    theme: united
  pdf_document: 
    pandoc_args: ["--lua-filter=color-text.lua"]
    keep_tex: true
header-includes:
  - \preauthor{\centering\large}
  - \predate{\centering\normalsize}
  - \pretitle{\centering\Large\textbf}
  - \usepackage{setspace}\onehalfspacing
  - \usepackage{xcolor}
  - \usepackage[shortlabels]{enumitem}
  - \usepackage{pgf,tikz, mathabx}
  - \usetikzlibrary{positioning}
editor_options:
  chunk_output_type: console
---
<style>

table, td, th {
  border: none;
  padding-left: 1em;
  padding-right: 1em;
  margin-left: auto;
  margin-right: auto;
  margin-top: 1em;
  margin-bottom: 1em;
}

</style>

```{cat, engine.opts = list(file = "color-text.lua")}
Span = function(span)
  color = span.attributes['color']
  -- if no color attribute, return unchange
  if color == nil then return span end
  
  -- tranform to <span style="color: red;"></span>
  if FORMAT:match 'html' then
    -- remove color attributes
    span.attributes['color'] = nil
    -- use style attribute instead
    span.attributes['style'] = 'color: ' .. color .. ';'
    -- return full span element
    return span
  elseif FORMAT:match 'latex' then
    -- remove color attributes
    span.attributes['color'] = nil
    -- encapsulate in latex code
    table.insert(
      span.content, 1,
      pandoc.RawInline('latex', '\\textcolor{'..color..'}{')
    )
    table.insert(
      span.content,
      pandoc.RawInline('latex', '}')
    )
    -- returns only span content
    return span.content
  else
    -- for other format return unchanged
    return span
  end
end
```

<!-- # Packages: -->

```{r,echo=FALSE,eval=TRUE,message=FALSE,warning=FALSE}
rm(list=ls())
library("dplyr")
library("ggplot2")
library(Hmisc)
library(gridExtra)
library(grid)
library("stargazer")
library("hrbrthemes")
#hrbrthemes::import_roboto_condensed()
library("quanteda")
library("readtext")
library("tidyverse")
library("knitr")
library("papeR")
library(tidyr)
library(kableExtra)
library(ggpubr)
library("printr")
library("tab")
#library("lfe")
library(sjPlot)
library(clusterSEs)
library(viridis)
library(BBmisc)
library(miceadds)
library(estimatr)
library(foreign)
library(randomizr)
library(doParallel)
library(sandwich)
library("table1")
library(matrixStats)
```

# Demonstrating with simulated data


```{r,echo=FALSE,eval=TRUE,message=FALSE,warning=FALSE}
# ----------------------------------------------------------------------
# Function 1: skip_to_attrite()
# ----------------------------------------------------------------------

#This function takes a matrix of 0,1s in which 1 indicates missingness (NA) per respondent per question and removes `skippers`. Skippers are individuals who have a 0s in their row followed by 1s.

skip_to_attrite<-function(arg){
    n_col = length(arg)
    for (j in 1:n_col)
       {
      if (prod(arg[j:n_col])==1)
        {
          arg[j] = 1
        } 
      else 
        {
          arg[j] = 0
         }
    }
    return(arg)
}
# ----------------------------------------------------------------------
# Function 2: attrition()
# ----------------------------------------------------------------------

#Function to transform dataframe into an attrition dataframe. The attrition dataframe indicates, per variable, how many respondents attrited [note that this dataframe does not include `skippers`, i.e. respondents who skipped questions]. The dataframe also includes a variable that is the proportion of total N attrited, calculated as number of attrited respondents / number of respondents entering into the question.

#only works if you know the order of survey questions. 

attrition <- function(data)
  {
  #required packages
  require(ggplot2)
  require(viridis)
  require(Hmisc)
  require(dplyr)
  
  #make sure arguments are correct
  if(is.null(data))
  stop("Data is null, please supply value")
  
  if(class(data)!="data.frame")
  stop("Data must be data.frame")
  
  #for each missing value in the dataframe `dataset` give value 1, otherwise give 0.
  data <- apply(data,2,function(x) {ifelse(is.na(x),1,0)})

  #change `skippers` into 0 (we are only interested in respondents that attrited).
 
  data<-apply(data,1,skip_to_attrite)
  data<-t(data) #transpose data

  data2<-data.frame(data)

  #transform into a long dataframe, such that the variable `attrited` is the number of missing observations per variable.
 data <- data.frame(colSums(data2))
 colnames(data) <- "attrited"
 
 #transform `attrited` to measure how many respondents attrited during each question, rather than how many missing values are in each question.
 attrite_2<-data$attrited
 num_dropped <- data[-1,] - data[-nrow(data),]
 data$attrited<- c(data[1,], num_dropped)
 data$attrite_2<-attrite_2
 
  #add variable `proportion` = number of attrited respondents / number of respondents entering into the question
 data$n_prev <- nrow(data2) - as.numeric(data$attrite_2)
 data$n_prev <- Lag(data$n_prev, +1)
 data$n_prev[1] <- nrow(data2)
 data$proportion <-    round(data$attrited/data$n_prev,2)
 data$n_prev <- NULL
 data$attrite_2 <- NULL
 
 #proportion of attrited / starting N
 data$proportion2 <- round(data$attrited/nrow(data2),2)
 
 #add variable `questions` = the name of each variable in the original dataframe.
 data$questions <- rownames(data)
 rownames(data) <- c()
 
  #return dataframe
  return(data)
}

#attrition_dataset<-attrition(data = df)

# ----------------------------------------------------------------------
# Function 3: plot_attrition()
# ----------------------------------------------------------------------

#Function that allows you to plot attrition in survey data.

#`data` must be data.frame. Note that this function works only if the order of variables = order of questions in the survey.

#`freq` is a logical argument that notes the Y axis of the attrition plot. Default is freq=TRUE, which is the frequency of attrited respondents. When freq=FALSE Y axis is the proportion of total N attrited, calculated as number of attrited respondents / number of respondents entering into the question.

#`treatment` is a character of name(s) of question(s) in which treatments were administered. Marked in the plot with a red vertical line.

#`pre_treatment` is a character of name(s) of pre-treatment question(s). Marked in the plot with a green vertical line.

#`DV` is a character of name(s) of outcome question(s). Marked in the plot with a blue vertical line.

#`other_group_var` is a character of name(s) of question(s), corresponds to `other_group` category, specified by users. Marked in the plot with a purple vertical line. Note that both `other_group` and `other_group_var` must be specified to use one of the functions.

#`other_group` is a character of the name of the group of variables specified in `other_group_var`. Note that both `other_group` and `other_group_var` must be specified to use one of the functions.

plot_attrition <- function(data
                           ,freq = TRUE
                           ,treatment = NULL
                           ,pre_treatment = NULL
                           ,DV = NULL
                           ,other_group = NULL
                           ,other_group_var = NULL
                           ,title = NULL)
  { 
  #required packages
  require(ggplot2)
  require(viridis)
  require(Hmisc)
  require(dplyr)

  #make sure arguments are correctly specified
  if(is.null(data))
  stop("Data is null, please supply value")
  
  if(class(data)!="data.frame")
  stop("Data must be data.frame")
  
  if(class(freq)!="logical")
  stop("Freq must be logical. Default is freq=TRUE.")
  
  if(!is.null(treatment) & class(treatment)!="character")
  stop("Treatment must be character")
  
  if(!is.null(pre_treatment) & class(pre_treatment)!="character")
  stop("Pre_treatment must be character")
  
  if(!is.null(DV) & class(DV)!="character")
  stop("DV must be character")
  
  if(!is.null(other_group) & class(other_group)!="character")
  stop("Other_group must be character")
  
  if(!is.null(other_group_var) & class(other_group_var)!="character")
  stop("Other_group_var must be character")
  
  #both other_group_var and group_var must be specified to use either:
  if(!is.null(other_group_var) & is.null(other_group))
  stop("Specify name of other_group")
  
  if(is.null(other_group_var) & !is.null(other_group))
  stop("Specify other_group_var")

 
 #Begin by creating an attrition dataframe
 #for each missing value in the dataframe `dataset` give value 1, otherwise give 0.
  data <- apply(data,2,function(x) {ifelse(is.na(x),1,0)})

  #change `skippers` into 0 (we are only interested in respondents that attrited).
 
  data<-apply(data,1,skip_to_attrite)
  data<-t(data) #transpose data

  data2<-data.frame(data)
  
  #transform into a long dataframe, such that the variable `attrited` is the number of missing observations per variable.
 data <- data.frame(colSums(data2))
 colnames(data) <- "attrited"
 
 #transform `attrited` to measure how many respondents attrited during each question, rather than how many missing values are in each question.
 attrite_2<-data$attrited
 num_dropped <- data[-1,] - data[-nrow(data),]
 data$attrited<- c(data[1,], num_dropped)
 data$attrite_2<-attrite_2
 
  #add variable `proportion` = number of attrited respondents / number of respondents entering into the question
 data$n_prev <- nrow(data2) - as.numeric(data$attrite_2)
 data$n_prev <- Lag(data$n_prev, +1)
 data$n_prev[1] <- nrow(data2)
 data$proportion <-   round(data$attrited/data$n_prev,2)
 data$n_prev <- NULL
 data$attrite_2 <- NULL
 
 #add variable `questions` = the name of each variable in the original dataframe.
 data$questions <- rownames(data)
 rownames(data) <- c()
 data$questions <- factor(data$questions, levels=data$questions)

  #Next, plot attrition
  #set colors for plots
   tmp_colors<-viridis(n=2,alpha=0.6,begin=0.25,end=1,direction=1,option="D")
   
  #create figure for if treatment is not NULL and freq = TRUE
    p <- data %>%
    ggplot(aes(questions,{if(freq==FALSE){proportion}else{attrited}})) + 
      #add if statement based on freq
          
      geom_histogram(color="#e9ecef", alpha=0.6, stat = 'identity') +
      scale_fill_manual(values=tmp_colors) 
    
     #vlines
      
      #add vline for other_group, only if it isn't null
    if(!is.null(other_group)) {
      p <- p + geom_vline(data= data.frame(type=other_group, 
                                col=other_group, other_group_var = other_group_var),
                                aes(colour=col, xintercept = match(other_group_var,data$questions)), #other_group_var), 
                                size = 0.7, show.legend = TRUE)} 
      #add vline for treatment, only if it isn't null   
    if(!is.null(treatment)){
      p <- p + geom_vline(data= data.frame(type="Treatment", 
                                col="Treatment", treatment = treatment),
                                aes(colour=col, xintercept = treatment), 
                                size = 0.7, show.legend = TRUE)}
      #add vline for pre_treatment, only if it isn't null   
    if(!is.null(pre_treatment)){
      p <- p + geom_vline(data= data.frame(type="Pre-Treatment", 
                                col="Pre-Treatment", pre_treatment = pre_treatment),
                                aes(colour=col, xintercept = pre_treatment), 
                                size = 0.7, show.legend = TRUE)}
      #add vline for DV, only if it isn't null   
    if(!is.null(DV)){
      p <- p + geom_vline(data= data.frame(type="Outcome", 
                                col="Outcome", DV = DV),
                                aes(colour=col, xintercept = DV), 
                                size = 0.7, show.legend = TRUE)} 
    
    #delete gray background  
    
    p <- p + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                          panel.background = element_blank(),
          axis.text.x = element_text(angle = 90, hjust = 1, size = 8))   
      
     #add legend details manually  
    p<- p + scale_colour_manual(name="Legend"
                      ,breaks = c("Treatment","Pre-Treatment","Outcome",other_group)
                      ,labels = c("Treatment","Pre-Treatment","Outcome",other_group)
                      ,values = c("firebrick","goldenrod3","royalblue3","seagreen")
                     ) +
      
        
    labs(x = "Survey Questions") + #titles
    labs(y = {if(freq==FALSE){"Proportion of respondents attrited"}
      else{"Respondents attrited"}}) #add if statement based on freq==FALSE
   
     #print the plot
    print(p)
}


plot_attrition <- function(data
                           ,freq = TRUE
                           ,treatment = NULL
                           ,pre_treatment = NULL
                           ,DV = NULL
                           ,other_group = NULL
                           ,other_group_var = NULL
                          ,treatment_color=NULL
                          ,pre_treatment_color=NULL
                          ,DV_color=NULL
                          ,other_group_color=NULL
                          ,title=NULL)
{ 
  #required packages
  require(ggplot2)
  require(viridis)
  require(Hmisc)
  require(dplyr)
  
  #make sure arguments are correctly specified
  if(is.null(data))
    stop("Data is null, please supply value")
  
  if(class(data)!="data.frame")
    stop("Data must be data.frame")
  
  if(class(freq)!="logical")
    stop("Freq must be logical. Default is freq=TRUE.")
  
  if(!is.null(treatment) & class(treatment)!="character")
    stop("Treatment must be character")
  
  if(!is.null(pre_treatment) & class(pre_treatment)!="character")
    stop("Pre_treatment must be character")
  
  if(!is.null(DV) & class(DV)!="character")
    stop("DV must be character")
  
  if(!is.null(other_group) & class(other_group)!="character")
    stop("Other_group must be character")
  
  if(!is.null(other_group_var) & class(other_group_var)!="character")
    stop("Other_group_var must be character")
  
  #both other_group_var and group_var must be specified to use either:
  if(!is.null(other_group_var) & is.null(other_group))
    stop("Specify name of other_group")
  
  if(is.null(other_group_var) & !is.null(other_group))
    stop("Specify other_group_var")
  #set colors
  if(is.null(treatment_color)) treatment_color<-"firebrick"
  if(is.null(pre_treatment_color)) pre_treatment_color<-"goldenrod3"
  if(is.null(DV_color)) DV_color<-"royalblue3"
  if(is.null(other_group_color)) other_group_color<-"seagreen"
  
  
  #Begin by creating an attrition dataframe
  #for each missing value in the dataframe `dataset` give value 1, otherwise give 0.
  data <- apply(data,2,function(x) {ifelse(is.na(x),1,0)})
  
  #change `skippers` into 0 (we are only interested in respondents that attrited).
  
  data<-apply(data,1,skip_to_attrite)
  data<-t(data) #transpose data
  
  data2<-data.frame(data)
  
  #transform into a long dataframe, such that the variable `attrited` is the number of missing observations per variable.
  data <- data.frame(colSums(data2))
  colnames(data) <- "attrited"
  
  #transform `attrited` to measure how many respondents attrited during each question, rather than how many missing values are in each question.
  attrite_2<-data$attrited
  num_dropped <- data[-1,] - data[-nrow(data),]
  data$attrited<- c(data[1,], num_dropped)
  data$attrite_2<-attrite_2
  
  #add variable `proportion` = number of attrited respondents / number of respondents entering into the question
  data$n_prev <- nrow(data2) - as.numeric(data$attrite_2)
  data$n_prev <- Lag(data$n_prev, +1)
  data$n_prev[1] <- nrow(data2)
  data$proportion <-   round(data$attrited/data$n_prev,2)
  data$n_prev <- NULL
  data$attrite_2 <- NULL
  
  #add variable `questions` = the name of each variable in the original dataframe.
  data$questions <- rownames(data)
  rownames(data) <- c()
  data$questions <- factor(data$questions, levels=data$questions)
  
  #Next, plot attrition
  #set colors for plots
  
  tmp_colors<-viridis(n=2,alpha=0.6,begin=0.25,end=1,direction=1,option="D")
  
  #create figure for if treatment is not NULL and freq = TRUE
  if(!freq){
  p <- ggplot(data, aes(x=questions,y=proportion)) + 
    geom_bar(stat = 'identity') +
    geom_histogram(color="#e9ecef", alpha=0.6, stat = 'identity') +
    scale_fill_manual(values=tmp_colors) 
}else{
  p <- ggplot(data,aes(questions,attrited)) + 
    geom_histogram(color="#e9ecef", alpha=0.6, stat = 'identity') +
    scale_fill_manual(values=tmp_colors) 
}
  
  #vlines
  if(freq){line_data<-data$attrited
    }else{line_data<-data$proportion}
  #add vline for other_group, only if it isn't null
  if(!is.null(other_group)) {
    p <- p + geom_vline(data= data.frame(type=other_group, col=other_group, other_group_var = other_group_var),
                        aes(colour=col, xintercept = which(data$questions%in%other_group_var)), #other_group_var), 
                        size = 0.7, show.legend = TRUE)
    } 
  #add vline for treatment, only if it isn't null   
  if(!is.null(treatment)){
    p <- p + geom_vline(data= data.frame(type="Treatment", col="Treatment", treatment = treatment),
                        aes(colour=col, xintercept = which(data$questions%in%treatment)), 
                        size = 0.7, show.legend = TRUE)
    }
  #add vline for pre_treatment, only if it isn't null   
  if(!is.null(pre_treatment)){
    p <- p + geom_vline(data= data.frame(type="Pre-Treatment", col="Pre-Treatment", pre_treatment = pre_treatment),
                        aes(colour=col, xintercept = which(data$questions%in%pre_treatment)), 
                        size = 0.7, show.legend = TRUE)}
  #add vline for DV, only if it isn't null   
  if(!is.null(DV)){
    p <- p + geom_vline(data= data.frame(type="Outcome", col="Outcome", DV = DV),
                        aes(colour=col, xintercept = which(data$questions%in%DV)), 
                        size = 0.7, show.legend = TRUE)} 
  
  #delete gray background  
  if(!freq){title_y<-"Proportion of respondents attrited"}else{title_y<-"Respondents attrited"}
  if(!freq){c <- 1}else{c <-nrow(data)}
  
  p <- p + theme(panel.grid.major = element_blank()
                 ,panel.grid.minor = element_blank()
                 ,panel.background = element_blank()
                 ,axis.text.x = element_text(angle = 90, hjust = 1, size = 8)) +
    scale_colour_manual(name="Legend" ,breaks = c("Treatment","Pre-Treatment","Outcome",other_group)
                              ,labels = c("Treatment","Pre-Treatment","Outcome",other_group)
                              ,values= c("firebrick","goldenrod3","royalblue3","seagreen")) +
                        #,values = unname(c(treatment_color,pre_treatment_color,DV_color,other_group_color))) +
    labs(x = "Survey Questions") + #titles
    labs(y = title_y) + 
    ylim(0,c)
  
  return(p+ggtitle(title))
}

```




## Pre-treatment Attrition

```{r}
#Generate simulated data
n <- 100
df <- data.frame(
Q1 = sample(c(18:90), n, rep = TRUE), #age
Q2 = sample(c("m", "f"), n, rep = TRUE, prob = c(0.55, 0.45)), #sex
Q3 = sample(c(0,1), n, rep = TRUE), #other general pre-treatment questions
Q4 = sample(c(0,1), n, rep = TRUE),
Q5 = sample(c("treatment", "control"), n, rep = TRUE), #we will assume Q5 is the treatment
Q6 = sample(c(0,1), n, rep = TRUE), #post treatment questions
Q7 = sample(c(0,1), n, rep = TRUE),
Q8 = sample(c(0,1), n, rep = TRUE),
Q9 = sample(c(0,1), n, rep = TRUE),
Q10 = sample(c(0,1), n, rep = TRUE))

#Generate attrition randomly
invisible(
sapply(sample(1:nrow(df), 14),function(x) {
    a <- sample(1:4,1)
    df[x,a:ncol(df)] <<- NA
}
))


#plot attrition
plot_attrition(data = df
               ,treatment = "Q5"
              ,pre_treatment = c("Q1", "Q2", "Q3", "Q4")
               ,DV = c("Q9", "Q10")
               ,other_group = "Mediators"
               ,other_group_var = c("Q6", "Q7", "Q8")
               ,freq = FALSE
              ,title = "Pre-treatment Attrition"
               )

#plot balance across treatment and control
table1(~ Q1 + Q2 | Q5, render.missing=NULL, data=df)

#change dataframe to long dataframe such that 1 = NA
df_attrite <- apply(df,2,function(x) {ifelse(is.na(x),1,0)})

#transform dataframe such that 1 in Q where respondent attrited, 0 otherwise
find_dropped_q<-function(arg){
    n_col = ncol(arg)
    n_row = nrow(arg)
    for (i in 1:n_row){
          for (j in 2:n_col)
       {
      if (arg[i,j-1]==1)
        {
          arg[i,j:n_col] = 0
          break
      } 
      }
    }
    return(arg)
}

a<-find_dropped_q(df_attrite)

#map attrition across data
#heatmap(as.matrix(a), Colv = NA, Rowv = NA, scale="row")

#Q11<-colSums(as.matrix(a))
#Q11<-sort(Q11)
#vec<-names(Q11)
#a[vec]
#heatmap(as.matrix(a[vec]), Colv = NA, Rowv = NA, scale="row")

```


```{r}
df<-df %>% arrange(Q5)
df_n<-df
df_n$ID<-1:100
newdata <- subset(df_n, Q5=="treatment", select=ID)
newdata2 <- subset(df_n, Q5=="control", select=ID)

#Q11<-colSums(as.matrix(a))
#Q11<-sort(Q11)
#vec<-names(Q11)
#a[vec]
#heatmap(as.matrix(a[vec]), Colv = NA, Rowv = NA, scale="row")

df_attrite <- apply(df,2,function(x) {ifelse(is.na(x),1,0)})

find_dropped_q<-function(arg){
    n_col = ncol(arg)
    n_row = nrow(arg)
    for (i in 1:n_row){
          for (j in 2:n_col)
       {
      if (arg[i,j-1]==1)
        {
          arg[i,j:n_col] = 0
          break
      } 
      }
    }
    return(arg)
}

df<-find_dropped_q(df_attrite)
df<-as.data.frame(df)

library(tidyverse)
library(reshape)

rows_1 <- newdata$ID
rows_2 <- newdata2$ID

dat1 <- reshape::melt(df) %>%
  mutate(y = rep(1:100, 10)) %>%
  `colnames<-`(c("x", "value", "y")) %>%
  mutate(value = as.factor(value),
         fill2 = ifelse(y %in% rows_1, "treatment",
                        ifelse(y %in% rows_2, "control", NA)))

cols <- c("attrited" = "black", "0" = "white", "treatment" = "red", "control" = "blue")

ggplot(dat1, aes(x, y)) +
  geom_tile(aes(fill = value)) +
  geom_tile(aes(fill = fill2), alpha = 0.3) +
  scale_fill_manual(values = cols) +
  ylab("Respondents") +
  xlab ("Questions")
```

## Attrition at treatment

```{r}
#Generate simulated data
df2 <- data.frame(
Q1 = sample(c(18:90), n, rep = TRUE), #age
Q2 = sample(c("m", "f"), n, rep = TRUE, prob = c(0.55, 0.45)), #sex
Q3 = sample(c(0,1), n, rep = TRUE), #other general pre-treatment questions
Q4 = sample(c(0,1), n, rep = TRUE),
Q5 = sample(c("treatment", "control"), n, rep = TRUE), #we will assume Q5 is the treatment
Q6 = sample(c(0,1), n, rep = TRUE), #post treatment questions
Q7 = sample(c(0,1), n, rep = TRUE),
Q8 = sample(c(0,1), n, rep = TRUE),
Q9 = sample(c(0,1), n, rep = TRUE),
Q10 = sample(c(0,1), n, rep = TRUE))

#Generate attrition after treatment
invisible(
sapply(sample(1:nrow(df2), 14),function(x) {
    a <- sample(5:6,1)
    df2[x,a:ncol(df2)] <<- NA
}
)) #attrition rate is 14.


plot_attrition(data = df2
               ,treatment = "Q5"
              ,pre_treatment = c("Q1", "Q2", "Q3", "Q4")
               ,DV = c("Q9", "Q10")
               ,other_group = "Mediators"
               ,other_group_var = c("Q6", "Q7", "Q8")
               ,freq = FALSE
              ,title = "Attrition at treatment"
               ) 

table1(~ Q1 + Q2 | Q5, render.missing=NULL, data=df2, excel=1)


```


```{r}
df2<-df2 %>% arrange(Q5)
df2_n<-df2
df2_n$ID<-1:100
newdata <- subset(df2_n, Q5=="treatment", select=ID)
newdata2 <- subset(df2_n, Q5=="control", select=ID)

#Q11<-colSums(as.matrix(a))
#Q11<-sort(Q11)
#vec<-names(Q11)
#a[vec]
#heatmap(as.matrix(a[vec]), Colv = NA, Rowv = NA, scale="row")

df2_attrite <- apply(df2,2,function(x) {ifelse(is.na(x),1,0)})
df2<-find_dropped_q(df2_attrite)
df2<-as.data.frame(df2)

library(tidyverse)
library(reshape)

rows_1 <- newdata$ID
rows_2 <- newdata2$ID

dat1 <- reshape::melt(df2) %>%
  mutate(y = rep(1:100, 10)) %>%
  `colnames<-`(c("x", "value", "y")) %>%
  mutate(value = as.factor(value),
         fill2 = ifelse(y %in% rows_1, "treatment",
                        ifelse(y %in% rows_2, "control", NA)))

cols <- c("attrited" = "black", "0" = "white", "treatment" = "red", "control" = "blue")

ggplot(dat1, aes(x, y)) +
  geom_tile(aes(fill = value)) +
  geom_tile(aes(fill = fill2), alpha = 0.3) +
  scale_fill_manual(values = cols) +
  ylab("Respondents") +
  xlab ("Questions")
```

## Attrition after treatment (DV)

```{r}
#Generate simulated data
df3 <- data.frame(
Q1 = sample(c(18:90), n, rep = TRUE), #age
Q2 = sample(c("m", "f"), n, rep = TRUE, prob = c(0.55, 0.45)), #sex
Q3 = sample(c(0,1), n, rep = TRUE), #other general pre-treatment questions
Q4 = sample(c(0,1), n, rep = TRUE),
Q5 = sample(c("treatment", "control"), n, rep = TRUE), #we will assume Q5 is the treatment
Q6 = sample(c(0,1), n, rep = TRUE), #post treatment questions
Q7 = sample(c(0,1), n, rep = TRUE),
Q8 = sample(c(0,1), n, rep = TRUE),
Q9 = sample(c(0,1), n, rep = TRUE),
Q10 = sample(c(0,1), n, rep = TRUE))

#Generate attrition after treatment
invisible(
sapply(sample(1:nrow(df3), 14),function(x) {
    a <- sample(9:10,1)
    df3[x,a:ncol(df3)] <<- NA
}
))

plot_attrition(data = df3
               ,treatment = "Q5"
              ,pre_treatment = c("Q1", "Q2", "Q3", "Q4")
               ,DV = c("Q9", "Q10")
               ,other_group = "Mediators"
               ,other_group_var = c("Q6", "Q7", "Q8")
               ,freq = FALSE
              ,title = "Attrition post-treatment"
               ) 
table1(~ Q1 + Q2 | Q5,  render.missing=NULL, data=df3, excel=1)
```


```{r}
df3<-df3 %>% arrange(Q5)
df3_n<-df3
df3_n$ID<-1:100
newdata <- subset(df3_n, Q5=="treatment", select=ID)
newdata2 <- subset(df3_n, Q5=="control", select=ID)

#Q11<-colSums(as.matrix(a))
#Q11<-sort(Q11)
#vec<-names(Q11)
#a[vec]
#heatmap(as.matrix(a[vec]), Colv = NA, Rowv = NA, scale="row")

df3_attrite <- apply(df3,2,function(x) {ifelse(is.na(x),1,0)})
df3<-find_dropped_q(df3_attrite)
df3<-as.data.frame(df3)

library(tidyverse)
library(reshape)

rows_1 <- newdata$ID
rows_2 <- newdata2$ID

dat1 <- reshape::melt(df3) %>%
  mutate(y = rep(1:100, 10)) %>%
  `colnames<-`(c("x", "value", "y")) %>%
  mutate(value = as.factor(value),
         fill2 = ifelse(y %in% rows_1, "treatment",
                        ifelse(y %in% rows_2, "control", NA)))

cols <- c("attrited" = "black", "0" = "white", "treatment" = "red", "control" = "blue")

ggplot(dat1, aes(x, y)) +
  geom_tile(aes(fill = value)) +
  geom_tile(aes(fill = fill2), alpha = 0.3) +
  scale_fill_manual(values = cols) +
  ylab("Respondents") +
  xlab ("Questions")
```



# Demonstrating with real data from Lo, Renshon, and Bassan-Nygate 2021 (study 5B)

```{r call-data, echo=FALSE, eval=TRUE, message=FALSE,warning=FALSE}
#Clean data
test_data <- read.csv("Praise and Empathy -- Study 6_February 16, 2021_08.34.csv",header=T, na.strings=c("", " ", "NA"))
test_data <- test_data[3:nrow(test_data),]
test_data <- as.data.frame(test_data)
test_data$attrition_1<- test_data$Q612
test_data$attrition_2<-test_data$Q614_7
test_data$ideology<-test_data$Q606
test_data$post
test_data2<- test_data[, c("consent", "age", "sex", "education", "state", "income", "part_id", "race", "religion", "attrition_1", "attrition_2", "cards_a", "pa", "pb_1", "pb_2", "pb_3", "pc", "cards_b", "p2a", "p2b_1", "p2b_2", "p2b_3", "p2c", "treat1", "Happy_1_1", "Happy_1_2", "Happy_1_3", "cards1", "X1a", "X1b_1", "X1b_2", "X1b_3", "X1c", "treat2", "Happy_2_1", "Happy_2_2", "Happy_2_3","cards2", "X2a", "X2b_1", "X2b_2", "X2b_3", "X2c", "treat3", "Happy_3_1", "Happy_3_2", "Happy_3_3","cards3", "X3a", "X3b_1", "X3b_2", "X3b_3", "post1", "post2_7", "post3", "post4", "post5", "post6", "post7", "post8", "post9", "post10", "post11_1", "post11_8", "post13_1", "post14_1", "post15_1", "post16_1", "post17", "ideology", "trump_approval", "pres_approval")]

plot_attrition(data = test_data2
               ,treatment = c("treat1", "treat2", "treat3")
              ,pre_treatment = c("consent", "age", "sex", "education", "state", "income", "part_id", "race", "religion", "attrition_1", "attrition_2", "cards_a", "pa", "pb_1", "pb_2", "pb_3", "pc", "cards_b", "p2a", "p2b_1", "p2b_2", "p2b_3", "p2c")
               ,DV = c("cards1", "cards2",  "cards3")
               ,other_group = "Mediators"
               ,other_group_var = c("Happy_1_1", "Happy_1_2", "Happy_1_3",
                                    "Happy_2_1", "Happy_2_2", "Happy_2_3",
                                    "Happy_3_1", "Happy_3_2", "Happy_3_3")
               ,freq = FALSE
               )   

```

